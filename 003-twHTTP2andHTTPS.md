---
marp: true
---

<!--
theme: gaia
_footer: © 2019 shion.ueda
_class: lead
-->

# ﾁｮｯﾄﾜｶﾙ HTTP/2とHTTPS

2019-00-00（WIP）
shion.ueda

---

## 目次

- HTTP年表
- HTTP/2
- TLS
- HTTPS（HTTP/2 over TLS）
- （HTTP/3）

---

## HTTP年表

年|ﾊﾞｰｼﾞｮﾝ|説明
-|-|-
1990|HTTP/0.9|GETメソッドのみ。<br>URLで特定されるHTMLを取得するだけのものだった
1996|HTTP/1.0|POSTやDELETEメソッドを追加。<br>フォーマットにヘッダーが登場したのはこの時
1997|HTTP/1.1|Keep-AliveやHTTPパイプラインをサポート。<br>**TLS**を用いてセキュアなHTTPS通信が可能になった
2015|**HTTP/2**|HTTP/1.1との完全な後方互換性を保ちつつ、時代に合わせたさまざまな機能を追加したもの

---

<!--_class: lead -->

## HTTP/2

---

## HTTP/2とは

2015年の5月に公開されたHTTPの新バージョン。
HTTP/1を改良し、大量コンテンツの送受信に対応できる設計となった。
<br>

> 2018年はじめには、世界トップ1000のウェブサイトのうち**ほぼ40%がHTTP/2で動作**しており、Firefoxが発行する**getレスポンスのうちおよそ70%のHTTPSリクエストをHTTP/2が占め**、 ...

HTTP3 explained - https://http3-explained.haxx.se/ja/why-h2.html

---

## HTTP/2の特徴

完全な後方互換性を維持したまま新たな転送手段を提供し、
より少ない通信量で迅速なやり取りを行うことができる仕組み。

- **HTTP/1.1との完全な後方互換性を維持**
  HTTPバージョンが違うサーバー、クライアントでも通信ができる！
  - ポート番号はHTTP/1.1と同じ
    - 80番：HTTP（HTTP/1.1 over TCP、~~HTTP/2 over TCP~~）
    - 443番：HTTPS（HTTP/1.1 over TLS、HTTP/2 over TLS）

- 通信を早くするための仕組みもいろいろ追加

---

## HTTP/2の新機能

- **ストリーム**を用いた非同期な接続の多重化（順序やブロッキングの廃止）
- テキストの代わりに**バイナリベース**の通信
- 必要であろうファイルをキャッシュさせる**サーバープッシュ**

- HTTP2**ヘッダーの圧縮**

---

## ストリーム

---

## バイナリベースの通信

---

## サーバープッシュ

foo <!-- not a comment -- two hyphens -->

---

<!--_class: lead -->

## SSL/TLS

HTTPSの前に語らないといけないもの

---

## SSL/TLSとは

**Transport Layer Security**（TLS）はインターネットでセキュアな通信を
行うために開発されているプロトコル。クレジットカード情報などを守る。

- 通信データを暗号化することで盗聴しても内容が分からないようにする
- 通信データが伝送される途中で改ざんされた時にそれを検出する
- 通信相手が正しいということを確認できる
※電子証明書に含まれる公開鍵と電子証明書の有効性チェックを使用

要は、安全な通信を行うための仕組み！

---

## SSL/TLS年表

年|ﾊﾞｰｼﾞｮﾝ|説明
-|-|-
1994〜1998|SSL1.0〜SSL3.0|現在、SSLはもう使うべきではない
1999|TLS1.0|SSL3.0の後継者。SSL3.1とも
2006|TLS1.1|
2008|TLS1.2|今回は1.2の話
2018|TLS1.3|1.3で規格がちょっと変わった

今現在、一般的にSSLと呼ばれているものは**TLS**のことを指す。
TLSは**SSL/TLS**と呼ばれることもが多いが、SSLとの互換性はない。

---

## TLSの利用用途

HTTPのような、平文で通信をする仕組みと組み合わせて利用する。

通常のプロトコル|ポート|TLSと組み合わせたプロトコル|ポート|
-|-|-|-
HTTP|80|**HTTPS**|443
SMTP|25|SMTPS|465
FTP|20|FTPS|989
IMAP|43|IMAPS|993
POP3|10|POP3S|995

---

## TLS1.2を用いた通信

TLSではTCPによるコネクションを確立した後、TLSを使った暗号通信のセッションを確立する。
これを**TLSハンドシェイク**と呼ぶ。

TLSハンドシェイクの最終的な目的は**安全に共通鍵を交換する**ことであり、セッションの確立には**公開鍵**も使用される。
（ハイブリッド方式と呼ばれる）

![bg left 96%](images/003/tls.png)

---

## TLSハンドシェイク①

TLSハンドシェイクは正しく接続されたクライアントと、特定されない鍵（**master secret**）を共有するための仕組み。

中間者攻撃や改竄に耐えられる仕組みとなっているが、**3Wayハンドシェイク**（1.5RTT）に加えてかなりの通信が必要になる。

![bg left 42%](images/003/tls3way.png)

---

## TLSハンドシェイク②

TLSハンドシェイクは、大きく4つのフェーズに分けられる。

1. 通信に必要な情報の合意
2. 鍵共有に必要な情報の送信（サーバーからクライアント）
3. 鍵共有に必要な情報の送信（クライアントからサーバー）
4. セッション確立作業の完了

![bg left 42%](images/003/tls3way.png)

---

## フェーズ1

接続の要求と、通信で決めないといけない内容の合意を取る。

クライアントはサーバーに
**CipherSuiteのリスト**を渡し、サーバーはリストから都合の良いCipherSuiteを選んで合意する

それと同時に、お互いが生成した**乱数**を送り合っておく。（共通鍵の生成に必要）

![bg left 90%](images/003/tls3way-1.png)

---

## CipherSuite（暗号スイート）①

暗号通信と一言で言っても、通信は単純なものでない。通信フローは複数の `暗号技術` や `ハッシュ関数` を組み合わせて情報を暗号化しているため。

たとえばTLSではアプリケーション層のデータを `共通鍵方式` で暗号化するが、その共通鍵は `公開鍵方式` で暗号化して受け渡しを行っている。しかも、共通鍵暗号や公開鍵暗号のアルゴリズムは1つでなく、複数存在する。

- 共通鍵暗号方式：AES、Blowfish、Camellia、CAST-256、DES...
- 公開鍵暗号方式：RSA、DSA、楕円曲線暗号...

---

## CipherSuite（暗号スイート）②

**CipherSuite**（**暗号スイート**）はTLSのような複数の暗号方式を利用する
プロトコルで、「この場所にはRSA、この場所にはDES」とあらかじめ決めておいた組み合わせの決まりのことを言う。

TLSのCipherSuiteは次のような文字列で表される。

- `TLS_RSA_WITH_3DES_EDE_CBC_SHA`
- `TLS_RSA_WITH_AES_256_GCM_SHA384`
- `TLS_CHACHA20_POLY1305_SHA256`
- など

---

## CipherSuiteの合意

**ClientHello**では、**CipherSuiteのリスト**とその他の情報を送信する。
**ServerHello**では、送信されたリストから都合の良い暗号スイートを選択し、その他の情報と合わせてクライアントに送信する。

ここで選択された暗号化の形式がこの通信では使用される。

![bg left 90%](images/003/tls3way-1.png)

---

## フェーズ2

サーバーがクライアントに、通信で必要な情報を送信する。

- 作成したサーバー公開鍵
- **サーバー電子証明書**
  - ルート証明書までのリストを含む（証明書チェーン）
    - **ルート認証局**の証明書
    - **中間認証局**の証明書

![bg left 90%](images/003/tls3way-2.png)

---

## 電子証明書

---

## フェーズ3

クライアントがサーバーに、通信で必要な情報を送信する。

この際、送信されてきたサーバー電子証明書が正しいものであるかの検証も行う。

- サーバー公開鍵で暗号化した乱数 **プリマスタシークレット**
- クライアント証明書

![bg left 90%](images/003/tls3way-3.png)

---

## 共通鍵の計算

フェーズ3まで完了したなら、TLSハンドシェイクで交換したかった共通鍵を生成することができる。（フェーズ4を始める前に共通鍵を生成する！）

ここまで完了した時点で、お互いの手元には3つの要素が存在する。

- クライアントで生成した乱数（フェーズ1）
- サーバーで生成した乱数（フェーズ1）
- プリマスタシークレット（フェーズ3）

---

## 共通鍵の計算：マスターシークレットを手に入れる

マスターシークレット（48バイト）は、この3つの要素をPRF（疑似乱数関数）にかけることで生成される。ここで生成された文字列の上48桁を切り取ることで、マスターシークレットを手に入れることができる。

```c
master_secret = PRF(プリマスタシークレット, "master secret",
                    クライアント乱数 + サーバー乱数)[0..47];
```

PRFはデータを受け取り、任意のデータを出するハッシュ関数。
計算には2つのハッシュアルゴリズムを組み合わせられており、どちらか片方のアルゴリズムがセキュアなら結果としてセキュアであると保証される方法が用いられる。

---

## 共通鍵の計算：キーブロックを手に入れる

生成されたマスターシークレットをもう一あPRF（疑似乱数関数）にかけることで、キーブロックを手に入れることが出来る。

```c
key_block = PRF(マスタシークレット, "key expansion",
                クライアント乱数 + サーバー乱数);
```

---

## フェーズ3：ClientCertificat

ServerHelloDoneを受け取ったクライアントは、まず必要ならClientCertificateでクライアント証明書を送信します。

---

## フェーズ3：ClientKeyExchange

このメッセージは必ず送信される。

このメッセージによって**premaster_secret**（共通鍵）が生成される。ここで生成された共通鍵は渡された公開鍵で暗号化され、サーバーに送信される。



---

## フェーズ3：CertificateRequest

---

## フェーズ3：CertificateVerify

クライアント証明書で署名が可能な場合、ClientKeyExchangeに引き続いて、CertificateVerifyで、これまでのヘッダのやり取りを署名して、クライアントがきちんとデータをやり取りしていることの証明とします。

---

## フェーズ3②

すべての情報を送信し終えたら、最後に**ClientHelloDone**を送信してサーバーからの送信フェーズを終了する。

![bg left 90%](images/003/tls3way-3.png)

---

## フェーズ4

お互い、暗号通信に入ることの宣言**ChangeCipherSpec**を投げたタイミングで暗号通信が始まる。

最後に送信される**Finished**は共通鍵で暗号化されており、これを返すことでハンドシェイクが完了となる。

![bg left 90%](images/003/tls3way-4.png)

---
![bg 96%](images/003/tls.png)
![bg 43%](images/003/tls3way.png)

---

<!--_class: lead -->

## HTTPS

---

## HTTPSとは

- TLSを使用したHTTP通信

---

## HTTP/2とHTTPS

規格上ではHTTP/2もTLS無しの状態（`http`）で利用できるが、
ブラウザのほとんどがTLS無しのHTTP/2を禁止しているため
HTTP/2は事実上TLS必須（`https://`）という状態になっている。

（プライバシ保護で、通信でHTTPSを必須とする動きが進んでいるため）

||TLS無し（http）|TLS有り（https）
-|-|-
HTTP/1.1|○|○
HTTP/2|×|○

---

HTTP/2はHTTP/1.1と完全な互換性が保たれており、使用するデフォルトのポート番号もhttpの場合80番、httpsの場合443番で変わらない。

また、HTTP/2ではポート番号とは別に、どのような方式で接続を行うかを決めるための「識別子」が定義されている。定義されている識別子は「h2」（HTTP/2 over TLS）と「h2c」（HTTP/2 over TCP）の2つで、h2はTLSで保護されたコネクション上（いわゆるhttps）でHTTP/2を利用することを示し、h2cは暗号化されていないTCPコネクション上（いわゆるhttp）でHTTP/2を利用して通信を行うことを示すものだ。

またHTTP/2の仕様ではHTTP及びHTTPS両方の配信に対応していますが、クライアント側（ブラウザなど）はHTTP/2にTLSを必要とするため、実質HTTPSでの配信のみHTTP/2が利用できるということになります。

---

- https://knowledge.sakura.ad.jp/7734/
- https://qiita.com/uutarou10/items/7698ee3336c70a482843#http2%E3%81%AE%E7%89%B9%E5%BE%B4
- https://http2.info/faq.html#why-is-http2-binary
- https://qiita.com/0xfffffff7/items/39b944e3845ab3776b63
