---
marp: true
---

<!--
theme: gaia
_footer: © 2019 shion.ueda
_class: lead
-->

# ﾁｮｯﾄﾜｶﾙ HTTP/2とHTTPS

2019-00-00（WIP）
shion.ueda

---

## 目次

- HTTP年表
- HTTP/2
- TLS
- HTTPS（HTTP/2 over TLS）
- （HTTP/3）

---

## HTTP年表

年|ﾊﾞｰｼﾞｮﾝ|説明
-|-|-
1990|HTTP/0.9|GETメソッドのみ。<br>URLで特定されるHTMLを取得するだけのものだった
1996|HTTP/1.0|POSTやDELETEメソッドを追加。<br>フォーマットにヘッダーが登場したのはこの時
1997|HTTP/1.1|Keep-AliveやHTTPパイプラインをサポート。<br>**TLS**を用いてセキュアなHTTPS通信が可能になった
2015|**HTTP/2**|HTTP/1.1との完全な後方互換性を保ちつつ、時代に合わせたさまざまな機能を追加したもの

---

<!--_class: lead -->

## HTTP/2

---

## HTTP/2とは

2015年の5月に公開されたHTTPの新バージョン。
HTTP/1を改良し、大量コンテンツの送受信に対応できる設計となった。
<br>

> 2018年はじめには、世界トップ1000のウェブサイトのうち**ほぼ40%がHTTP/2で動作**しており、Firefoxが発行する**getレスポンスのうちおよそ70%のHTTPSリクエストをHTTP/2が占め**、 ...

HTTP3 explained - https://http3-explained.haxx.se/ja/why-h2.html

---

## HTTP/2の特徴

完全な後方互換性を維持したまま新たな転送手段を提供し、
より少ない通信量で迅速なやり取りを行うことができる仕組み。

- **HTTP/1.1との完全な後方互換性を維持**
  HTTPバージョンが違うサーバー、クライアントでも通信ができる！
  - ポート番号はHTTP/1.1と同じ
    - 80番：HTTP（HTTP/1.1 over TCP、~~HTTP/2 over TCP~~）
    - 443番：HTTPS（HTTP/1.1 over TLS、HTTP/2 over TLS）

- 通信を早くするための仕組みもいろいろ追加

---

## HTTP/2の新機能

- **ストリーム**を用いた非同期な接続の多重化（順序やブロッキングの廃止）
- テキストの代わりに**バイナリベース**の通信
- 必要であろうファイルをキャッシュさせる**サーバープッシュ**

- HTTP2**ヘッダーの圧縮**

---

## ストリーム

---

## バイナリベースの通信

---

## サーバープッシュ

foo <!-- not a comment -- two hyphens -->

---

<!--_class: lead -->

## SSL/TLS

HTTPSの前に語らないといけないもの

---

## SSL/TLSとは

**Transport Layer Security**（TLS）はインターネットでセキュアな通信を
行うために開発されているプロトコル。クレジットカード情報などを守る。

- 通信データを暗号化することで盗聴しても内容が分からないようにする
- 通信データが伝送される途中で改ざんされた時にそれを検出する
- 通信相手が正しいということを確認できる
※電子証明書に含まれる公開鍵と電子証明書の有効性チェックを使用

要は、安全な通信を行うための仕組み！

---

## SSL/TLS年表

年|ﾊﾞｰｼﾞｮﾝ|説明
-|-|-
1994〜1998|SSL1.0〜SSL3.0|現在、SSLはもう使うべきではない
1999|TLS1.0|SSL3.0の後継者。SSL3.1とも
2006|TLS1.1|
2008|TLS1.2|今回は1.2あたりの話
2018|TLS1.3|1.3で規格がちょっと変わった…

今現在、一般的にSSLと呼ばれているものは**TLS**のことを指す。
TLSは**SSL/TLS**と呼ばれることもが多いが、SSLとの互換性はない。

---

## TLSの利用用途

HTTPのような、平文で通信をする仕組みと組み合わせて利用する。

通常のプロトコル|ポート|TLSと組み合わせたプロトコル|ポート|
-|-|-|-
HTTP|80|**HTTPS**|443
SMTP|25|SMTPS|465
FTP|20|FTPS|989
IMAP|43|IMAPS|993
POP3|10|POP3S|995

---

## TLS1.2を用いた通信

TLSではTCPによるコネクションを確立した後、TLSを使った暗号通信のセッションを確立する。
これを**TLSハンドシェイク**と呼ぶ。

TLSハンドシェイクの最終的な目的は**安全に共通鍵を交換する**ことであり、セッションの確立には**公開鍵**も使用される。
（ハイブリッド方式と呼ばれる）

![bg left 96%](images/003/tls.png)

---

## TLSハンドシェイク①

TLSハンドシェイクは正しく接続されたクライアントと、特定されない鍵（**共通鍵**）を共有するための仕組み。

中間者攻撃や改竄を検知する仕組みが複数組み込まれるが、**3Wayハンドシェイク**（1.5RTT）に加えてかなりの通信が必要になる。

![bg left 42%](images/003/tls3way.png)

---

## TLSハンドシェイク②

TLSハンドシェイクは、大きく4つのフェーズに分けられる。

1. 通信に必要な情報の合意
2. 鍵共有に必要な情報の送信（サーバーからクライアント）
3. 鍵共有に必要な情報の送信（クライアントからサーバー）
4. セッション確立作業の完了

![bg left 42%](images/003/tls3way.png)

---

## フェーズ1

接続の要求と、通信で決めないといけない内容の合意を取る。

クライアントはサーバーに
**CipherSuiteのリスト**を渡し、サーバーはリストから都合の良いCipherSuiteを選んで合意する

それと同時に、お互いが生成した**乱数**を送り合っておく。
（鍵の生成に必要）

![bg left 90%](images/003/tls3way-1.png)

---

## CipherSuite（暗号スイート）①

暗号通信と一言で言っても、通信は単純なものでない。通信フローは複数の `暗号技術` や `ハッシュ関数` を組み合わせて情報を暗号化しているため。

たとえばTLSではアプリケーション層のデータを `共通鍵方式` で暗号化するが、その共通鍵は `公開鍵方式` で暗号化して受け渡しを行っている。しかも、共通鍵暗号や公開鍵暗号のアルゴリズムは1つでなく、複数存在する。

- 共通鍵暗号方式：AES、Blowfish、Camellia、CAST-256、DES...
- 公開鍵暗号方式：RSA、DSA、楕円曲線暗号...

---

## CipherSuite（暗号スイート）②

**CipherSuite**（**暗号スイート**）はTLSのような複数の暗号方式を利用する
プロトコルで、「この場所にはRSA、この場所にはDES」とあらかじめ決めておいた組み合わせの決まりのことを言う。

TLSのCipherSuiteは次のような文字列で表される。

- `TLS_RSA_WITH_3DES_EDE_CBC_SHA`
- `TLS_RSA_WITH_AES_256_GCM_SHA384`
- `TLS_CHACHA20_POLY1305_SHA256`
- など

---

## CipherSuiteの合意

**ClientHello**では、**CipherSuiteのリスト**とその他の情報を送信する。
**ServerHello**では、送信されたリストから都合の良い暗号スイートを選択し、その他の情報と合わせてクライアントに送信する。

ここで選択された暗号化の形式がこの通信では使用される。

![bg left 90%](images/003/tls3way-1.png)

---

## フェーズ2

サーバーがクライアントに、通信で必要な情報を送信する。

- 作成したサーバー公開鍵
- **サーバー電子証明書**
  - ルート証明書までのリストを含む（証明書チェーン）
    - **ルート認証局**の証明書
    - **中間認証局**の証明書

![bg left 90%](images/003/tls3way-2.png)

---

## 電子証明書

現実世界で言うところのパスポートのようなもので、インターネットで自分や相手が本人であることを証明するための仕組み。信頼された第三者が通信相手を本人であると証明することで、改竄やなりすましを防ぐ。

公開鍵証明書認証局（**CA**、Certificate Authority）と呼ばれる組織によって発行されており、たとえば次のような認証局がある。

- VeriSign
- シマンテック
- Let's Encrypt

---

## 電子証明書の認証レベル

- DV証明書：ドメイン認証（レベル1）
  - ドメインに登録されている登録者を確認することで発行
  - Let's EncryptはDV証明書のみ発行している
- OV証明書：企業認証（レベル2）
  - ドメインに加え、運営している組織の実在性を証明することで発行
- EV証明書：EV認証（レベル3）
  - ドメインや企業の実在性に加え、所在地の認証を行うことで発行

---

## ルート証明書と中間証明書

登録者に電子証明書を発行する認証局は**中間認証局**と呼ばれており、この中間認証局が発行する電子証明書は**中間証明書**。（Let's Encryptなどが当てはまる）

中間認証局の身元を証明する認証局を**ルート認証局**と呼び、ルート認証局はルート証明書を発行する。Let's Encryptのルート証明書はIden Trustというルート認証局が署名している。信頼できるルート証明書はOSやブラウザにインストールされており、ここに該当しないルート証明書を使用するサイトは一般的に危険なサイトとみなされる。

---

## フェーズ3


クライアントはサーバー電子証明書が正しいものであるか検証し、問題なければ必要な情報をサーバーに送信する。

- サーバー公開鍵で暗号化した乱数 **プリマスタシークレット**
- クライアント証明書
  - サーバーは証明書が正しいものであるか検証する

![bg left 90%](images/003/tls3way-3.png)

---

## プリマスタシークレット

共通鍵を生成するための「マスターシークレット」を生成するための情報。
（46バイトの乱数とバージョン番号をサーバ公開鍵で暗号化したもの。）

クライアントがClientKeyExchangeの工程で生成し、サーバーに送信する。
この際、クライアントもプリマスタシークレットを保持しておく。

---

## 共通鍵の計算

フェーズ3まで完了したなら、TLSハンドシェイクで交換したかった共通鍵を生成することができる。（フェーズ4を始める前に共通鍵を生成する！）

ここまで完了した時点で、お互いの手元には3つの要素が存在する。

- クライアントで生成した乱数（フェーズ1）
- サーバーで生成した乱数（フェーズ1）
- プリマスタシークレット（フェーズ3）

---

## 共通鍵の計算：マスターシークレットを手に入れる

マスターシークレット（48バイト）は、この3つの要素をPRF（疑似乱数関数）にかけることで生成される。ここで生成された文字列の上48桁を切り取ることで、マスターシークレットを手に入れることができる。

```c
master_secret = PRF(プリマスタシークレット, "master secret",
                    クライアント乱数 + サーバー乱数)[0..47];
```

PRFはデータを受け取り、任意のデータを出するハッシュ関数。
計算には2つのハッシュアルゴリズムを組み合わせられており、どちらか片方のアルゴリズムがセキュアなら結果としてセキュアになる。

---

## 共通鍵の計算：キーブロックを手に入れる

生成されたマスターシークレットをもう一度PRF（疑似乱数関数）にかけることで、キーブロックを手に入れることができる。

```c
key_block = PRF(マスタシークレット, "key expansion",
                クライアント乱数 + サーバー乱数);
```

キーブロックで得られた乱数を指定の長さで切り出して鍵として使用する。

- Client_write_MAC_secret、Server_write_MAC_secret（認証鍵）
- Client_write_key、Server_write_key（暗号鍵）
- Client_write_IV、Server_write_IV（初期ベクトル）

---

## 共通鍵の計算：共通鍵を手に入れる

※クライアンとサーバーで対になる鍵の中身は同じ。
　Client_write_keyとServer_write_keyなど。

生成されたwrite_keyをPRF（疑似乱数関数）にかけることで、
最終的な通信に使用する鍵（共通鍵）を手に入れることができる。

```c
final_write_key = PRF(write_key,
                クライアント乱数 + サーバー乱数);
```

残りのwrite_MAC_secretとwrite_IVは中間者攻撃を防ぐため使用する。

---

## フェーズ4

お互い、暗号通信に入ることの宣言**ChangeCipherSpec**を投げたタイミングで暗号通信が始まる。

最後に送信される**Finished**は共通鍵で暗号化されており、これを返すことでハンドシェイクが完了となる。

*共通鍵共有できた！*

![bg left 90%](images/003/tls3way-4.png)

---

![bg 96%](images/003/tls.png)
![bg 43%](images/003/tls3way.png)

---

<!--_class: lead -->

## HTTPS

---

## HTTPSとは

- TLSを使用したHTTP通信

---

## HTTP/2とHTTPS

規格上ではHTTP/2もTLS無しの状態（`http`）で利用できるが、
ブラウザのほとんどがTLS無しのHTTP/2を禁止しているため
HTTP/2は事実上TLS必須（`https://`）という状態になっている。

（プライバシ保護で、通信でHTTPSを必須とする動きが進んでいるため）

||TLS無し（http）|TLS有り（https）
-|-|-
HTTP/1.1|○|○
HTTP/2|×|○

---

HTTP/2はHTTP/1.1と完全な互換性が保たれており、使用するデフォルトのポート番号もhttpの場合80番、httpsの場合443番で変わらない。

また、HTTP/2ではポート番号とは別に、どのような方式で接続を行うかを決めるための「識別子」が定義されている。定義されている識別子は「h2」（HTTP/2 over TLS）と「h2c」（HTTP/2 over TCP）の2つで、h2はTLSで保護されたコネクション上（いわゆるhttps）でHTTP/2を利用することを示し、h2cは暗号化されていないTCPコネクション上（いわゆるhttp）でHTTP/2を利用して通信を行うことを示すものだ。

またHTTP/2の仕様ではHTTP及びHTTPS両方の配信に対応していますが、クライアント側（ブラウザなど）はHTTP/2にTLSを必要とするため、実質HTTPSでの配信のみHTTP/2が利用できるということになります。

---

- https://knowledge.sakura.ad.jp/7734/
- https://qiita.com/uutarou10/items/7698ee3336c70a482843#http2%E3%81%AE%E7%89%B9%E5%BE%B4
- https://http2.info/faq.html#why-is-http2-binary
- https://qiita.com/0xfffffff7/items/39b944e3845ab3776b63
